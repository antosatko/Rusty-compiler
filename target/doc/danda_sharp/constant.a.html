<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Memory: -stack array of values includes stack pointer - each item (last stack alloc, last position in bin) stack: [value; MAX] stack_guide: [{end: usize, code_ptr: usize}; 100] allocation rules: […hardcoded_values(startup), …written_values(runtime)] res size: […current, reg(0), …other] -heap array of values accessed only with a pointer losing pointer also discards its value, hopefuly heap: [value_ptr; MAX] -global array of values, read-only no stack pointer, compiler handles pointer -registers used to store data for performing transformations 0: transformation results 1: function return values / other data to transform 2: uvidim -value Values::(value: Type): enum"><meta name="keywords" content="rust, rustlang, rust-lang, a"><title>a in danda_sharp - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../danda_sharp/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../danda_sharp/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><div class="sidebar-elems"><h2 class="location"><a href="index.html">In danda_sharp</a></h2><div id="sidebar-vars" data-name="a" data-ty="constant" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../danda_sharp/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Constant <a href="index.html">danda_sharp</a>::<wbr><a class="constant" href="#">a</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/danda_sharp/main.rs.html#226">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust const"><code>pub(crate) const a: <a class="primitive" href="https://doc.rust-lang.org/1.62.0/std/primitive.f32.html">f32</a> = 1.;</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Memory:
-stack
array of values
includes stack pointer - each item (last stack alloc, last position in bin)
stack: [value; MAX]
stack_guide: [{end: usize, code_ptr: usize}; 100]
allocation rules:
[…hardcoded_values(startup), …written_values(runtime)]
res size: […current, reg(0), …other]
-heap
array of values accessed only with a pointer
losing pointer also discards its value, hopefuly
heap: [value_ptr; MAX]
-global
array of values, read-only
no stack pointer, compiler handles pointer
-registers
used to store data for performing transformations
0: transformation results
1: function return values / other data to transform
2: uvidim
-value
Values::<Type>(value: Type): enum</p>
<p>Instructions:
wr stack_offset       |01| write          | moves value from reg(0) to stack(&lt;stack_offset&gt; + stack_end)
rd stack_offset reg   |02| read           | loads value from stack(&lt;stack_offset&gt; + stack_end) to its reg(<reg>)
wrr stack_offset size |03| write range    | moves value from reg(0) to all pos on stack(&lt;stack_offset&gt; + stack_end..&lt;stack_offset&gt; + stack_end + <size>)
wrp reg1 reg2         |04| write pointer  | moves value from reg(<reg2>) to stack(<reg1>)
rdp reg1 reg2         |05| read pointer   | loads value from stack(reg1) to its reg(<reg2>)
rdc stack_pos reg     |06| read constant  | loads value from stack(&lt;stack_pos&gt;) to its reg(<reg>)
ptr stack_offset      |07| pointer        | stores pointer to stack(stack_end - &lt;stack_offset&gt;) in reg(0)
alc reg size          |08| allocate       | reserves <size> on heap and stores location in registers(<reg>)
goto pos              |09| go to          | moves code_pointer to <pos>
brnc pos1 pos2        |10| branch         | if reg(0), goto <pos1> else goto <pos2>
ret                   |11| return         | moves code_pointer to the last position in stack
res size              |12| reserve        | reserves <size> on stack and saves current reg(0)
mov reg1 reg2         |13| move           | moves value of <reg1> to <reg2>
ADD                   |14| add            | reg(0) is set to the result of operation: reg(0) + reg(1)
SUB                   |15| subtract       | reg(0) is set to the result of operation: reg(0) - reg(1)
MUL                   |16| multiply       | reg(0) is set to the result of operation: reg(0) * reg(1)
DIV                   |17| divide         | reg(0) is set to the result of operation: reg(0) / reg(1)
MOD                   |18| modulus        | reg(0) is set to the result of operation: reg(0) % reg(1)
EQU                   |19| equals         | reg(0) is set to the result of operation: reg(0) = reg(1)
GRT                   |20| greater than   | reg(0) is set to the result of operation: reg(0) &gt; reg(1)
AND                   |21| and            | reg(0) is set to the result of operation: reg(0) &amp; reg(1)
OR                    |22| or             | reg(0) is set to the result of operation: reg(0) | reg(1)
NOT                   |23| not            | reg(0) is set to the result of operation: !reg(0)
cal procedure args    |24| call           | calls external <procedure>(program state, <args>) written in rust (for syscalls etc..)
end                   |25| end            | terminates program
dalc reg              |26| de-allocate    | frees heap(<reg>)
ralc reg size         |27| allocate resize| resizes heap(<reg>) for <size>; additional space is filled with null
idx reg1 reg2         |28| Index          | gets pointer from reg(<reg1>) repairs it and adds reg(<reg2>)
repp reg              |29| Repair pointer | Repairs pointer in reg(<reg>)
LESS                  |30| less than      | reg(0) is set to the result of operation: reg(0) &lt; reg(1)
Gotop reg             |31| goto pointer   | moves code pointer to reg(<reg>)</p>
<p>Compilation rules:
{
let a: int = expression
}
-notes: positions.new(a, int, 1)
-print <expression> as expression
wr (positions.get(a))
{
let b: [int, 10]
}
-notes: positions.new(b, int, 10)
{
struct c{
a: int,
b: char,
c: [char, 30],
}
let d: c = {
a: 5,
b: ‘a’,
c: [‘a’, 30]
}
}</p>
<p>Excercise:
fn my_func(danda: int) -&gt; bool{
return true;
}
int danda2 = danda1 + 50;
bool danda3 = my_func(danda2);
if danda3 {
danda2 += 3;
} else {
danda2 -= danda2;
}</p>
<p>Translates to:
HEAD
hc_vars{
true: bool,
50: int,
3: int
}
CODE
#my_func
rdc 0 1
ret
#rest
rd (danda1.stack_offset) 0
rdc 1 1
add 0 1
wr (danda2.stack_offset) 0
rd (danda2.stack_offset) 0
wr (my_func.danda.stack_offset = 0) 0
res (sizeof(int))
goto (my_func)
wr (danda3.stack_offset) 1
rd (danda3.stack_offset) 0
brnc (pos1) (pos2)
#pos1
rdc 2 1
add
goto (if-statement-end)
#pos2
rd (danda2.stack_offset) 0
sub
#if-statement-end
end</p>
<p>scan order:
write all definitions, global vars, function headers and positions in source</p>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="danda_sharp" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.62.0 (a8314ef7d 2022-06-27)" ></div>
</body></html>